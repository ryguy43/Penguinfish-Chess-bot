... shell ...

I'll create a complete standalone HTML chess bot that runs directly in the browser:

```html project="Chess Bot HTML" file="chess-bot.html" type="code"
&lt;!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Chess AI Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #7c3aed 50%, #1e293b 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: bold;
            background: linear-gradient(to right, #a855f7, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .header p {
            color: #cbd5e1;
        }

        .game-layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            align-items: start;
        }

        @media (max-width: 1024px) {
            .game-layout {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }

        .card {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid #475569;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        .card-header {
            padding: 20px;
            border-bottom: 1px solid #475569;
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .card-content {
            padding: 20px;
        }

        .chess-board {
            display: inline-block;
            border: 4px solid #64748b;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
        }

        .board-row {
            display: flex;
        }

        .square {
            width: 64px;
            height: 64px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: bold;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .square:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .square.light {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
        }

        .square.dark {
            background: linear-gradient(135deg, #b45309, #92400e);
        }

        .square.highlighted {
            box-shadow: inset 0 0 0 4px #3b82f6;
            animation: pulse 1s infinite;
        }

        .square.selected {
            background: linear-gradient(135deg, #86efac, #22c55e) !important;
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }

        .square.check {
            background: linear-gradient(135deg, #fca5a5, #ef4444) !important;
            animation: pulse 1s infinite;
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 24px;
            height: 24px;
            background: #22c55e;
            border-radius: 50%;
            opacity: 0.8;
            animation: bounce 1s infinite;
        }

        .square.valid-capture::after {
            content: '';
            position: absolute;
            width: 56px;
            height: 56px;
            border: 4px solid #22c55e;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        .piece {
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s ease;
            z-index: 10;
        }

        .piece:hover {
            transform: scale(1.1);
        }

        .coordinate {
            position: absolute;
            font-size: 0.75rem;
            font-weight: bold;
            opacity: 0.7;
            color: #374151;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 4px;
            padding: 2px 4px;
        }

        .coordinate.rank {
            top: 4px;
            left: 4px;
        }

        .coordinate.file {
            bottom: 4px;
            right: 4px;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .badge.white {
            background: white;
            color: black;
        }

        .badge.black {
            background: #1f2937;
            color: white;
        }

        .badge.active {
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #374151;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #3b82f6, #8b5cf6);
            transition: width 0.3s ease;
        }

        .controls {
            display: grid;
            gap: 16px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .label {
            font-size: 0.875rem;
            color: #cbd5e1;
        }

        .select, .slider {
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 6px;
            color: white;
            padding: 8px 12px;
        }

        .select:focus, .slider:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }

        .button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.875rem;
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button.primary {
            background: #22c55e;
            color: white;
        }

        .button.primary:hover:not(:disabled) {
            background: #16a34a;
        }

        .button.secondary {
            background: transparent;
            color: white;
            border: 1px solid #4b5563;
        }

        .button.secondary:hover:not(:disabled) {
            background: #374151;
        }

        .button.danger {
            background: #ef4444;
            color: white;
        }

        .button.danger:hover:not(:disabled) {
            background: #dc2626;
        }

        .tabs {
            margin-bottom: 16px;
        }

        .tab-list {
            display: flex;
            background: #374151;
            border-radius: 6px;
            padding: 4px;
        }

        .tab-button {
            flex: 1;
            padding: 8px 12px;
            background: transparent;
            border: none;
            color: #9ca3af;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.75rem;
        }

        .tab-button.active {
            background: white;
            color: black;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .evaluation-bar {
            width: 100%;
            height: 12px;
            background: #374151;
            border-radius: 6px;
            overflow: hidden;
            margin: 8px 0;
        }

        .evaluation-fill {
            height: 100%;
            background: linear-gradient(to right, #ef4444, #eab308, #22c55e);
            transition: width 0.5s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
        }

        .move-list {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .move-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(55, 65, 81, 0.5);
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 0.875rem;
        }

        .thinking-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #cbd5e1;
            font-size: 0.875rem;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #374151;
            border-top: 2px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }

        .icon {
            width: 20px;
            height: 20px;
            display: inline-block;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            border-radius: 6px;
            padding: 12px;
            color: #fca5a5;
            font-size: 0.875rem;
            margin-top: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Advanced Chess AI Arena</h1>
            <p>Experience next-generation chess intelligence</p>
        </div>

        <div class="game-layout">
            &lt;!-- Chess Board Section -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span class="icon">👑</span>
                        Chess Board
                    </div>
                    <div class="status-bar">
                        <div>
                            <span class="badge white" id="white-badge">Player (White)</span>
                            <span class="badge black" id="black-badge">AI (Black)</span>
                        </div>
                    </div>
                    <div id="game-status">Ready to play</div>
                    <div id="thinking-indicator" class="thinking-indicator" style="display: none;">
                        <div class="spinner"></div>
                        AI is calculating...
                        <div class="progress-bar">
                            <div class="progress-fill" id="thinking-progress"></div>
                        </div>
                    </div>
                </div>
                <div class="card-content">
                    <div id="chess-board" class="chess-board"></div>
                </div>
            </div>

            &lt;!-- Control Panel -->
            <div style="display: flex; flex-direction: column; gap: 20px;">
                &lt;!-- Game Controls -->
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">
                            <span class="icon">⚡</span>
                            Game Controls
                        </div>
                    </div>
                    <div class="card-content">
                        <div class="controls">
                            <div class="form-group">
                                <label class="label">Game Mode</label>
                                <select id="game-mode" class="select">
                                    <option value="player-vs-bot">Player vs AI</option>
                                    <option value="bot-vs-bot">AI vs AI</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label class="label">AI Strength: <span id="difficulty-label">Master (7)</span></label>
                                <input type="range" id="difficulty-slider" class="slider" min="1" max="10" value="7">
                                <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: #9ca3af;">
                                    <span>Beginner</span>
                                    <span>Stockfish Level</span>
                                </div>
                            </div>

                            <div class="button-group">
                                <button id="start-btn" class="button primary">Start</button>
                                <button id="pause-btn" class="button secondary" disabled>Pause</button>
                                <button id="reset-btn" class="button danger">Reset</button>
                            </div>
                        </div>
                    </div>
                </div>

                &lt;!-- Analysis Panel -->
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">
                            <span class="icon">🎯</span>
                            Game Analysis
                        </div>
                    </div>
                    <div class="card-content">
                        <div class="tabs">
                            <div class="tab-list">
                                <button class="tab-button active" data-tab="evaluation">Evaluation</button>
                                <button class="tab-button" data-tab="moves">Moves</button>
                                <button class="tab-button" data-tab="stats">Statistics</button>
                            </div>
                        </div>

                        &lt;!-- Evaluation Tab -->
                        <div id="evaluation-tab" class="tab-content active">
                            <div id="evaluation-content">
                                <div style="text-align: center; padding: 40px 0; color: #9ca3af;">
                                    <div class="icon" style="font-size: 3rem; margin-bottom: 8px;">🧠</div>
                                    <p>Start playing to see AI analysis</p>
                                </div>
                            </div>
                        </div>

                        &lt;!-- Moves Tab -->
                        <div id="moves-tab" class="tab-content">
                            <div id="move-list" class="move-list">
                                <div style="text-align: center; padding: 40px 0; color: #9ca3af;">
                                    <p>No moves yet</p>
                                </div>
                            </div>
                        </div>

                        &lt;!-- Statistics Tab -->
                        <div id="stats-tab" class="tab-content">
                            <div class="stats-grid">
                                <div>
                                    <h4 style="margin-bottom: 8px; display: flex; align-items: center; gap: 4px;">
                                        <span class="icon">🛡️</span>
                                        White Stats
                                    </h4>
                                    <div style="display: flex; flex-direction: column; gap: 4px;">
                                        <div class="stat-item">
                                            <span>Captures:</span>
                                            <span id="white-captures">0</span>
                                        </div>
                                        <div class="stat-item">
                                            <span>Checks:</span>
                                            <span id="white-checks">0</span>
                                        </div>
                                        <div class="stat-item">
                                            <span>Castled:</span>
                                            <span id="white-castled">No</span>
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <h4 style="margin-bottom: 8px; display: flex; align-items: center; gap: 4px;">
                                        <span class="icon">⚔️</span>
                                        Black Stats
                                    </h4>
                                    <div style="display: flex; flex-direction: column; gap: 4px;">
                                        <div class="stat-item">
                                            <span>Captures:</span>
                                            <span id="black-captures">0</span>
                                        </div>
                                        <div class="stat-item">
                                            <span>Checks:</span>
                                            <span id="black-checks">0</span>
                                        </div>
                                        <div class="stat-item">
                                            <span>Castled:</span>
                                            <span id="black-castled">No</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #4b5563;">
                                <div class="stat-item">
                                    <span>Total Moves:</span>
                                    <span id="total-moves">0</span>
                                </div>
                                <div class="stat-item">
                                    <span>Game Status:</span>
                                    <span id="game-status-stat">Ready</span>
                                </div>
                            </div>
                            <div id="error-display"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Chess Engine and Bot Implementation
        class ChessEngine {
            constructor() {
                this.gameState = this.getInitialGameState();
            }

            getInitialGameState() {
                const board = [
                    [
                        { type: "rook", color: "black" },
                        { type: "knight", color: "black" },
                        { type: "bishop", color: "black" },
                        { type: "queen", color: "black" },
                        { type: "king", color: "black" },
                        { type: "bishop", color: "black" },
                        { type: "knight", color: "black" },
                        { type: "rook", color: "black" },
                    ],
                    Array(8).fill(null).map(() => ({ type: "pawn", color: "black" })),
                    Array(8).fill(null),
                    Array(8).fill(null),
                    Array(8).fill(null),
                    Array(8).fill(null),
                    Array(8).fill(null).map(() => ({ type: "pawn", color: "white" })),
                    [
                        { type: "rook", color: "white" },
                        { type: "knight", color: "white" },
                        { type: "bishop", color: "white" },
                        { type: "queen", color: "white" },
                        { type: "king", color: "white" },
                        { type: "bishop", color: "white" },
                        { type: "knight", color: "white" },
                        { type: "rook", color: "white" },
                    ],
                ];

                return {
                    board,
                    turn: "white",
                    lastMove: null,
                    castlingRights: {
                        whiteKingSide: true,
                        whiteQueenSide: true,
                        blackKingSide: true,
                        blackQueenSide: true,
                    },
                    enPassantTarget: null,
                    halfMoveClock: 0,
                    fullMoveNumber: 1,
                };
            }

            getGameState() {
                return JSON.parse(JSON.stringify(this.gameState));
            }

            reset() {
                this.gameState = this.getInitialGameState();
            }

            copyState() {
                return JSON.parse(JSON.stringify(this.gameState));
            }

            setState(state) {
                this.gameState = JSON.parse(JSON.stringify(state));
            }

            isValidPosition(pos) {
                return pos.row >= 0 && pos.row &lt; 8 && pos.col >= 0 && pos.col &lt; 8;
            }

            getPiece(pos) {
                if (!this.isValidPosition(pos)) return null;
                return this.gameState.board[pos.row][pos.col];
            }

            setPiece(pos, piece) {
                if (this.isValidPosition(pos)) {
                    this.gameState.board[pos.row][pos.col] = piece;
                }
            }

            generateMoves(color) {
                const moves = [];
                const currentColor = color || this.gameState.turn;

                for (let row = 0; row &lt; 8; row++) {
                    for (let col = 0; col &lt; 8; col++) {
                        const piece = this.gameState.board[row][col];
                        if (piece && piece.color === currentColor) {
                            const pieceMoves = this.generatePieceMoves({ row, col }, piece);
                            moves.push(...pieceMoves);
                        }
                    }
                }

                return moves.filter((move) => this.isLegalMove(move));
            }

            generateMovesForPiece(position) {
                const piece = this.getPiece(position);
                if (!piece || piece.color !== this.gameState.turn) return [];

                const moves = this.generatePieceMoves(position, piece);
                return moves.filter((move) => this.isLegalMove(move));
            }

            generatePieceMoves(from, piece) {
                switch (piece.type) {
                    case "pawn":
                        return this.generatePawnMoves(from, piece);
                    case "rook":
                        return this.generateRookMoves(from, piece);
                    case "knight":
                        return this.generateKnightMoves(from, piece);
                    case "bishop":
                        return this.generateBishopMoves(from, piece);
                    case "queen":
                        return this.generateQueenMoves(from, piece);
                    case "king":
                        return this.generateKingMoves(from, piece);
                    default:
                        return [];
                }
            }

            generatePawnMoves(from, piece) {
                const moves = [];
                const direction = piece.color === "white" ? -1 : 1;
                const startRow = piece.color === "white" ? 6 : 1;
                const promotionRow = piece.color === "white" ? 0 : 7;

                // Forward move
                const oneStep = { row: from.row + direction, col: from.col };
                if (this.isValidPosition(oneStep) && !this.getPiece(oneStep)) {
                    if (oneStep.row === promotionRow) {
                        for (const promotionPiece of ["queen", "rook", "bishop", "knight"]) {
                            moves.push({
                                from,
                                to: oneStep,
                                piece,
                                promotionPiece,
                            });
                        }
                    } else {
                        moves.push({ from, to: oneStep, piece });
                    }

                    // Two steps from starting position
                    if (from.row === startRow) {
                        const twoSteps = { row: from.row + 2 * direction, col: from.col };
                        if (this.isValidPosition(twoSteps) && !this.getPiece(twoSteps)) {
                            moves.push({
                                from,
                                to: twoSteps,
                                piece,
                                enPassantTarget: oneStep,
                            });
                        }
                    }
                }

                // Captures
                for (const colOffset of [-1, 1]) {
                    const capturePos = { row: from.row + direction, col: from.col + colOffset };
                    if (this.isValidPosition(capturePos)) {
                        const target = this.getPiece(capturePos);

                        if (target && target.color !== piece.color) {
                            if (capturePos.row === promotionRow) {
                                for (const promotionPiece of ["queen", "rook", "bishop", "knight"]) {
                                    moves.push({
                                        from,
                                        to: capturePos,
                                        piece,
                                        capturedPiece: target,
                                        promotionPiece,
                                    });
                                }
                            } else {
                                moves.push({ from, to: capturePos, piece, capturedPiece: target });
                            }
                        }

                        // En passant capture
                        const enPassantTarget = this.gameState.enPassantTarget;
                        if (enPassantTarget && capturePos.row === enPassantTarget.row && capturePos.col === enPassantTarget.col) {
                            const capturedPawnPos = {
                                row: capturePos.row - direction,
                                col: capturePos.col,
                            };
                            const capturedPawn = this.getPiece(capturedPawnPos);
                            if (capturedPawn && capturedPawn.type === "pawn" && capturedPawn.color !== piece.color) {
                                moves.push({
                                    from,
                                    to: capturePos,
                                    piece,
                                    capturedPiece: capturedPawn,
                                    isEnPassant: true,
                                });
                            }
                        }
                    }
                }

                return moves;
            }

            generateRookMoves(from, piece) {
                const moves = [];
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

                for (const [rowDir, colDir] of directions) {
                    for (let i = 1; i &lt; 8; i++) {
                        const to = { row: from.row + i * rowDir, col: from.col + i * colDir };
                        if (!this.isValidPosition(to)) break;

                        const target = this.getPiece(to);
                        if (!target) {
                            moves.push({ from, to, piece });
                        } else {
                            if (target.color !== piece.color) {
                                moves.push({ from, to, piece, capturedPiece: target });
                            }
                            break;
                        }
                    }
                }

                return moves;
            }

            generateKnightMoves(from, piece) {
                const moves = [];
                const knightMoves = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1],
                ];

                for (const [rowOffset, colOffset] of knightMoves) {
                    const to = { row: from.row + rowOffset, col: from.col + colOffset };
                    if (this.isValidPosition(to)) {
                        const target = this.getPiece(to);
                        if (!target || target.color !== piece.color) {
                            moves.push({ from, to, piece, capturedPiece: target });
                        }
                    }
                }

                return moves;
            }

            generateBishopMoves(from, piece) {
                const moves = [];
                const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

                for (const [rowDir, colDir] of directions) {
                    for (let i = 1; i &lt; 8; i++) {
                        const to = { row: from.row + i * rowDir, col: from.col + i * colDir };
                        if (!this.isValidPosition(to)) break;

                        const target = this.getPiece(to);
                        if (!target) {
                            moves.push({ from, to, piece });
                        } else {
                            if (target.color !== piece.color) {
                                moves.push({ from, to, piece, capturedPiece: target });
                            }
                            break;
                        }
                    }
                }

                return moves;
            }

            generateQueenMoves(from, piece) {
                return [...this.generateRookMoves(from, piece), ...this.generateBishopMoves(from, piece)];
            }

            generateKingMoves(from, piece) {
                const moves = [];
                const directions = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1], [0, 1],
                    [1, -1], [1, 0], [1, 1],
                ];

                // Regular king moves
                for (const [rowOffset, colOffset] of directions) {
                    const to = { row: from.row + rowOffset, col: from.col + colOffset };
                    if (this.isValidPosition(to)) {
                        const target = this.getPiece(to);
                        if (!target || target.color !== piece.color) {
                            moves.push({ from, to, piece, capturedPiece: target });
                        }
                    }
                }

                // Castling moves
                if (piece.color === "white") {
                    if (this.gameState.castlingRights.whiteKingSide) {
                        const kingSideClear = !this.getPiece({ row: 7, col: 5 }) && !this.getPiece({ row: 7, col: 6 });
                        if (kingSideClear && 
                            !this.isSquareAttacked({ row: 7, col: 4 }, "black") &&
                            !this.isSquareAttacked({ row: 7, col: 5 }, "black") &&
                            !this.isSquareAttacked({ row: 7, col: 6 }, "black")) {
                            moves.push({
                                from,
                                to: { row: 7, col: 6 },
                                piece,
                                isCastling: true,
                            });
                        }
                    }

                    if (this.gameState.castlingRights.whiteQueenSide) {
                        const queenSideClear = !this.getPiece({ row: 7, col: 1 }) && 
                                             !this.getPiece({ row: 7, col: 2 }) && 
                                             !this.getPiece({ row: 7, col: 3 });
                        if (queenSideClear &&
                            !this.isSquareAttacked({ row: 7, col: 2 }, "black") &&
                            !this.isSquareAttacked({ row: 7, col: 3 }, "black") &&
                            !this.isSquareAttacked({ row: 7, col: 4 }, "black")) {
                            moves.push({
                                from,
                                to: { row: 7, col: 2 },
                                piece,
                                isCastling: true,
                            });
                        }
                    }
                } else {
                    if (this.gameState.castlingRights.blackKingSide) {
                        const kingSideClear = !this.getPiece({ row: 0, col: 5 }) && !this.getPiece({ row: 0, col: 6 });
                        if (kingSideClear &&
                            !this.isSquareAttacked({ row: 0, col: 4 }, "white") &&
                            !this.isSquareAttacked({ row: 0, col: 5 }, "white") &&
                            !this.isSquareAttacked({ row: 0, col: 6 }, "white")) {
                            moves.push({
                                from,
                                to: { row: 0, col: 6 },
                                piece,
                                isCastling: true,
                            });
                        }
                    }

                    if (this.gameState.castlingRights.blackQueenSide) {
                        const queenSideClear = !this.getPiece({ row: 0, col: 1 }) && 
                                             !this.getPiece({ row: 0, col: 2 }) && 
                                             !this.getPiece({ row: 0, col: 3 });
                        if (queenSideClear &&
                            !this.isSquareAttacked({ row: 0, col: 2 }, "white") &&
                            !this.isSquareAttacked({ row: 0, col: 3 }, "white") &&
                            !this.isSquareAttacked({ row: 0, col: 4 }, "white")) {
                            moves.push({
                                from,
                                to: { row: 0, col: 2 },
                                piece,
                                isCastling: true,
                            });
                        }
                    }
                }

                return moves;
            }

            isSquareAttacked(pos, byColor) {
                for (let row = 0; row &lt; 8; row++) {
                    for (let col = 0; col &lt; 8; col++) {
                        const piece = this.gameState.board[row][col];
                        if (piece && piece.color === byColor) {
                            const attacks = this.generatePieceMoves({ row, col }, piece);
                            if (attacks.some((move) => move.to.row === pos.row && move.to.col === pos.col)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            isLegalMove(move) {
                const originalState = this.copyState();

                try {
                    this.setPiece(move.to, move.piece);
                    this.setPiece(move.from, null);

                    if (move.isEnPassant && move.capturedPiece) {
                        const direction = move.piece.color === "white" ? 1 : -1;
                        this.setPiece({ row: move.to.row + direction, col: move.to.col }, null);
                    }

                    const isLegal = !this.isInCheck(move.piece.color);
                    return isLegal;
                } finally {
                    this.setState(originalState);
                }
            }

            isInCheck(color) {
                const checkColor = color || this.gameState.turn;
                const kingPos = this.getKingPosition(checkColor);
                if (!kingPos) return false;

                const opponentColor = checkColor === "white" ? "black" : "white";

                for (let row = 0; row &lt; 8; row++) {
                    for (let col = 0; col &lt; 8; col++) {
                        const piece = this.gameState.board[row][col];
                        if (piece && piece.color === opponentColor) {
                            const attacks = this.generatePieceMoves({ row, col }, piece);
                            if (attacks.some((move) => move.to.row === kingPos.row && move.to.col === kingPos.col)) {
                                return true;
                            }
                        }
                    }
                }

                return false;
            }

            getKingPosition(color) {
                for (let row = 0; row &lt; 8; row++) {
                    for (let col = 0; col &lt; 8; col++) {
                        const piece = this.gameState.board[row][col];
                        if (piece && piece.type === "king" && piece.color === color) {
                            return { row, col };
                        }
                    }
                }
                return null;
            }

            makeMove(move) {
                if (!this.isLegalMove(move)) return false;

                this.setPiece(move.to, move.piece);
                this.setPiece(move.from, null);

                if (move.isEnPassant && move.capturedPiece) {
                    const direction = move.piece.color === "white" ? 1 : -1;
                    this.setPiece({ row: move.to.row + direction, col: move.to.col }, null);
                }

                if (move.isCastling) {
                    if (move.to.col === 6) {
                        const rookFrom = { row: move.from.row, col: 7 };
                        const rookTo = { row: move.from.row, col: 5 };
                        const rook = this.getPiece(rookFrom);
                        if (rook) {
                            this.setPiece(rookTo, rook);
                            this.setPiece(rookFrom, null);
                        }
                    } else if (move.to.col === 2) {
                        const rookFrom = { row: move.from.row, col: 0 };
                        const rookTo = { row: move.from.row, col: 3 };
                        const rook = this.getPiece(rookFrom);
                        if (rook) {
                            this.setPiece(rookTo, rook);
                            this.setPiece(rookFrom, null);
                        }
                    }
                }

                if (move.promotionPiece) {
                    this.setPiece(move.to, {
                        type: move.promotionPiece,
                        color: move.piece.color,
                    });
                }

                this.updateCastlingRights(move);
                this.gameState.enPassantTarget = move.enPassantTarget || null;
                this.gameState.lastMove = move;
                this.gameState.turn = this.gameState.turn === "white" ? "black" : "white";

                if (this.gameState.turn === "white") {
                    this.gameState.fullMoveNumber++;
                }

                return true;
            }

            updateCastlingRights(move) {
                if (move.piece.type === "king") {
                    if (move.piece.color === "white") {
                        this.gameState.castlingRights.whiteKingSide = false;
                        this.gameState.castlingRights.whiteQueenSide = false;
                    } else {
                        this.gameState.castlingRights.blackKingSide = false;
                        this.gameState.castlingRights.blackQueenSide = false;
                    }
                }

                if (move.piece.type === "rook") {
                    if (move.piece.color === "white") {
                        if (move.from.row === 7 && move.from.col === 0) {
                            this.gameState.castlingRights.whiteQueenSide = false;
                        } else if (move.from.row === 7 && move.from.col === 7) {
                            this.gameState.castlingRights.whiteKingSide = false;
                        }
                    } else {
                        if (move.from.row === 0 && move.from.col === 0) {
                            this.gameState.castlingRights.blackQueenSide = false;
                        } else if (move.from.row === 0 && move.from.col === 7) {
                            this.gameState.castlingRights.blackKingSide = false;
                        }
                    }
                }

                if (move.capturedPiece && move.capturedPiece.type === "rook") {
                    if (move.capturedPiece.color === "white") {
                        if (move.to.row === 7 && move.to.col === 0) {
                            this.gameState.castlingRights.whiteQueenSide = false;
                        } else if (move.to.row === 7 && move.to.col === 7) {
                            this.gameState.castlingRights.whiteKingSide = false;
                        }
                    } else {
                        if (move.to.row === 0 && move.to.col === 0) {
                            this.gameState.castlingRights.blackQueenSide = false;
                        } else if (move.to.row === 0 && move.to.col === 7) {
                            this.gameState.castlingRights.blackKingSide = false;
                        }
                    }
                }
            }

            isCheckmate() {
                return this.isInCheck() && this.generateMoves().length === 0;
            }

            isStalemate() {
                return !this.isInCheck() && this.generateMoves().length === 0;
            }

            isGameOver() {
                return this.isCheckmate() || this.isStalemate();
            }

            moveToNotation(move) {
                const fromSquare = this.positionToAlgebraic(move.from);
                const toSquare = this.positionToAlgebraic(move.to);

                if (move.isCastling) {
                    return move.to.col === 6 ? "O-O" : "O-O-O";
                }

                const piece = move.piece.type === "pawn" ? "" : move.piece.type.charAt(0).toUpperCase();
                const capture = move.capturedPiece || move.isEnPassant ? "x" : "";
                const promotion = move.promotionPiece ? `=${move.promotionPiece.charAt(0).toUpperCase()}` : "";

                const originalState = this.copyState();
                let checkNotation = "";

                try {
                    this.makeMove(move);
                    if (this.isCheckmate()) {
                        checkNotation = "#";
                    } else if (this.isInCheck()) {
                        checkNotation = "+";
                    }
                } finally {
                    this.setState(originalState);
                }

                return `${piece}${fromSquare}${capture}${toSquare}${promotion}${checkNotation}`;
            }

            positionToAlgebraic(pos) {
                const file = String.fromCharCode(97 + pos.col);
                const rank = (8 - pos.row).toString();
                return file + rank;
            }
        }

        // Simplified Chess Bot
        class ChessBot {
            constructor() {
                this.difficulty = 7;
                this.positionCount = 0;
                this.maxTime = 3000;
                this.startTime = 0;
            }

            setDifficulty(level) {
                this.difficulty = Math.max(1, Math.min(10, level));
            }

            async getBestMoveWithAnalysis(engine, difficulty, currentPlayer) {
                if (difficulty !== undefined) {
                    this.setDifficulty(difficulty);
                }

                this.positionCount = 0;
                this.startTime = Date.now();

                const moves = engine.generateMoves();
                if (moves.length === 0) {
                    return { move: null, evaluation: 0, depth: 0, nodesSearched: 0 };
                }

                // For very low difficulty, make random moves more often
                if (this.difficulty &lt;= 2 && Math.random() &lt; 0.4) {
                    const randomMove = moves[Math.floor(Math.random() * moves.length)];
                    return {
                        move: randomMove,
                        evaluation: 0,
                        depth: 1,
                        nodesSearched: 1,
                    };
                }

                let bestMove = moves[0];
                let bestScore = Number.NEGATIVE_INFINITY;
                const searchDepth = Math.min(6, Math.max(2, Math.floor(this.difficulty / 2)));

                const orderedMoves = this.orderMoves(engine, moves);

                for (const move of orderedMoves) {
                    if (Date.now() - this.startTime > this.maxTime) break;

                    try {
                        const score = this.evaluateMove(engine, move, searchDepth);
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = move;
                        }
                    } catch (err) {
                        continue;
                    }
                }

                // Add strategic randomness for lower difficulties
                if (this.difficulty &lt; 7 && Math.random() &lt; (8 - this.difficulty) * 0.08) {
                    const goodMoves = moves.slice(0, Math.min(5, moves.length));
                    bestMove = goodMoves[Math.floor(Math.random() * goodMoves.length)];
                }

                return {
                    move: bestMove,
                    evaluation: bestScore,
                    depth: searchDepth,
                    nodesSearched: this.positionCount,
                };
            }

            orderMoves(engine, moves) {
                return moves.sort((a, b) => {
                    let scoreA = 0;
                    let scoreB = 0;

                    // Prioritize captures
                    if (a.capturedPiece) {
                        scoreA += 10 * this.getPieceValue(a.capturedPiece.type) - this.getPieceValue(a.piece.type);
                    }
                    if (b.capturedPiece) {
                        scoreB += 10 * this.getPieceValue(b.capturedPiece.type) - this.getPieceValue(b.piece.type);
                    }

                    // Prioritize promotions
                    if (a.promotionPiece) scoreA += 800;
                    if (b.promotionPiece) scoreB += 800;

                    // Prioritize castling
                    if (a.isCastling) scoreA += 50;
                    if (b.isCastling) scoreB += 50;

                    // Prioritize central moves
                    if (this.isCentralMove(a)) scoreA += 20;
                    if (this.isCentralMove(b)) scoreB += 20;

                    return scoreB - scoreA;
                });
            }

            isCentralMove(move) {
                return (
                    (move.piece.type === "knight" || move.piece.type === "bishop") &&
                    move.to.row >= 2 && move.to.row &lt;= 5 &&
                    move.to.col >= 2 && move.to.col &lt;= 5
                );
            }

            evaluateMove(engine, move, depth) {
                const originalState = engine.copyState();

                try {
                    if (!engine.makeMove(move)) {
                        return Number.NEGATIVE_INFINITY;
                    }

                    const score = this.minimax(engine, depth - 1, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, false);
                    return score;
                } catch (err) {
                    return Number.NEGATIVE_INFINITY;
                } finally {
                    engine.setState(originalState);
                }
            }

            minimax(engine, depth, alpha, beta, isMaximizing) {
                this.positionCount++;

                if (Date.now() - this.startTime > this.maxTime || depth &lt;= 0) {
                    return this.evaluatePosition(engine);
                }

                if (engine.isGameOver()) {
                    return this.evaluatePosition(engine);
                }

                const moves = engine.generateMoves();
                if (moves.length === 0) {
                    return this.evaluatePosition(engine);
                }

                const limitedMoves = moves.slice(0, Math.min(20, moves.length));
                const orderedMoves = this.orderMoves(engine, limitedMoves);

                if (isMaximizing) {
                    let maxEval = Number.NEGATIVE_INFINITY;

                    for (const move of orderedMoves) {
                        const originalState = engine.copyState();

                        try {
                            if (engine.makeMove(move)) {
                                const eval_ = this.minimax(engine, depth - 1, alpha, beta, false);
                                maxEval = Math.max(maxEval, eval_);
                                alpha = Math.max(alpha, eval_);

                                if (beta &lt;= alpha) {
                                    break;
                                }
                            }
                        } catch (err) {
                            continue;
                        } finally {
                            engine.setState(originalState);
                        }
                    }

                    return maxEval;
                } else {
                    let minEval = Number.POSITIVE_INFINITY;

                    for (const move of orderedMoves) {
                        const originalState = engine.copyState();

                        try {
                            if (engine.makeMove(move)) {
                                const eval_ = this.minimax(engine, depth - 1, alpha, beta, true);
                                minEval = Math.min(minEval, eval_);
                                beta = Math.min(beta, eval_);

                                if (beta &lt;= alpha) {
                                    break;
                                }
                            }
                        } catch (err) {
                            continue;
                        } finally {
                            engine.setState(originalState);
                        }
                    }

                    return minEval;
                }
            }

            evaluatePosition(engine) {
                const gameState = engine.getGameState();

                if (engine.isCheckmate()) {
                    return gameState.turn === "white" ? -20000 : 20000;
                }

                if (engine.isStalemate()) {
                    return 0;
                }

                let score = 0;

                // Material evaluation
                for (let row = 0; row &lt; 8; row++) {
                    for (let col = 0; col &lt; 8; col++) {
                        const piece = gameState.board[row][col];
                        if (piece) {
                            let value = this.getPieceValue(piece.type);
                            score += piece.color === "white" ? value : -value;

                            // Positional bonuses
                            if (piece.type === "pawn") {
                                // Encourage pawn advancement
                                const advancement = piece.color === "white" ? (6 - row) : (row - 1);
                                score += piece.color === "white" ? advancement * 10 : -advancement * 10;
                            }

                            // Central control bonus
                            if (row >= 2 && row &lt;= 5 && col >= 2 && col &lt;= 5) {
                                const bonus = piece.type === "knight" ? 30 : piece.type === "bishop" ? 20 : 10;
                                score += piece.color === "white" ? bonus : -bonus;
                            }
                        }
                    }
                }

                // Mobility bonus
                const whiteMoves = engine.generateMoves("white").length;
                const blackMoves = engine.generateMoves("black").length;
                score += (whiteMoves - blackMoves) * 5;

                // King safety
                if (engine.isInCheck("white")) score -= 100;
                if (engine.isInCheck("black")) score += 100;

                return gameState.turn === "white" ? score : -score;
            }

            getPieceValue(pieceType) {
                const pieceValues = {
                    pawn: 100,
                    knight: 320,
                    bishop: 330,
                    rook: 500,
                    queen: 900,
                    king: 20000,
                };
                return pieceValues[pieceType] || 0;
            }
        }

        // Game Controller
        class ChessGame {
            constructor() {
                this.engine = new ChessEngine();
                this.bot = new ChessBot();
                this.gameState = this.engine.getGameState();
                this.isPlaying = false;
                this.thinking = false;
                this.gameMode = "player-vs-bot";
                this.selectedPiece = null;
                this.validMoves = [];
                this.moveHistory = [];
                this.botDifficulty = 7;
                this.gameStats = {
                    captures: { white: 0, black: 0 },
                    checks: { white: 0, black: 0 },
                    castled: { white: false, black: false },
                };
                this.evaluation = null;

                this.initializeUI();
                this.renderBoard();
                this.updateUI();
            }

            initializeUI() {
                // Game mode selector
                document.getElementById('game-mode').addEventListener('change', (e) => {
                    this.gameMode = e.target.value;
                    this.resetGame();
                });

                // Difficulty slider
                const difficultySlider = document.getElementById('difficulty-slider');
                difficultySlider.addEventListener('input', (e) => {
                    this.botDifficulty = parseInt(e.target.value);
                    this.updateDifficultyLabel();
                });
                this.updateDifficultyLabel();

                // Control buttons
                document.getElementById('start-btn').addEventListener('click', () => this.startGame());
                document.getElementById('pause-btn').addEventListener('click', () => this.pauseGame());
                document.getElementById('reset-btn').addEventListener('click', () => this.resetGame());

                // Tab switching
                document.querySelectorAll('.tab-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const tabName = e.target.dataset.tab;
                        this.switchTab(tabName);
                    });
                });
            }

            updateDifficultyLabel() {
                const labels = [
                    "Beginner", "Novice", "Amateur", "Club Player", "Expert",
                    "Master", "International Master", "Grandmaster", "Super GM", "Stockfish"
                ];
                const label = labels[this.botDifficulty - 1] || "Unknown";
                document.getElementById('difficulty-label').textContent = `${label} (${this.botDifficulty})`;
            }

            switchTab(tabName) {
                // Update tab buttons
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabName}-tab`).classList.add('active');
            }

            renderBoard() {
                const boardElement = document.getElementById('chess-board');
                boardElement.innerHTML = '';

                const pieceSymbols = {
                    "white-king": "♔", "white-queen": "♕", "white-rook": "♖",
                    "white-bishop": "♗", "white-knight": "♘", "white-pawn": "♙",
                    "black-king": "♚", "black-queen": "♛", "black-rook": "♜",
                    "black-bishop": "♝", "black-knight": "♞", "black-pawn": "♟",
                };

                for (let row = 0; row &lt; 8; row++) {
                    const rowElement = document.createElement('div');
                    rowElement.className = 'board-row';

                    for (let col = 0; col &lt; 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;

                        const piece = this.gameState.board[row][col];
                        if (piece) {
                            const pieceElement = document.createElement('span');
                            pieceElement.className = 'piece';
                            pieceElement.textContent = pieceSymbols[`${piece.color}-${piece.type}`];
                            square.appendChild(pieceElement);
                        }

                        // Add coordinates
                        if (col === 0) {
                            const rankLabel = document.createElement('span');
                            rankLabel.className = 'coordinate rank';
                            rankLabel.textContent = 8 - row;
                            square.appendChild(rankLabel);
                        }
                        if (row === 7) {
                            const fileLabel = document.createElement('span');
                            fileLabel.className = 'coordinate file';
                            fileLabel.textContent = String.fromCharCode(97 + col);
                            square.appendChild(fileLabel);
                        }

                        // Add click handler
                        square.addEventListener('click', () => this.handleSquareClick(row, col));

                        rowElement.appendChild(square);
                    }

                    boardElement.appendChild(rowElement);
                }

                this.updateBoardHighlights();
            }

            updateBoardHighlights() {
                // Clear all highlights
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('highlighted', 'selected', 'check', 'valid-move', 'valid-capture');
                });

                // Highlight last move
                if (this.gameState.lastMove) {
                    const fromSquare = document.querySelector(`[data-row="${this.gameState.lastMove.from.row}"][data-col="${this.gameState.lastMove.from.col}"]`);
                    const toSquare = document.querySelector(`[data-row="${this.gameState.lastMove.to.row}"][data-col="${this.gameState.lastMove.to.col}"]`);
                    if (fromSquare) fromSquare.classList.add('highlighted');
                    if (toSquare) toSquare.classList.add('highlighted');
                }

                // Highlight selected piece
                if (this.selectedPiece) {
                    const selectedSquare = document.querySelector(`[data-row="${this.selectedPiece.row}"][data-col="${this.selectedPiece.col}"]`);
                    if (selectedSquare) selectedSquare.classList.add('selected');
                }

                // Highlight valid moves
                this.validMoves.forEach(move => {
                    const square = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                    if (square) {
                        const hasPiece = this.gameState.board[move.row][move.col];
                        square.classList.add(hasPiece ? 'valid-capture' : 'valid-move');
                    }
                });

                // Highlight king in check
                if (this.engine.isInCheck()) {
                    const kingPos = this.engine.getKingPosition(this.gameState.turn);
                    if (kingPos) {
                        const kingSquare = document.querySelector(`[data-row="${kingPos.row}"][data-col="${kingPos.col}"]`);
                        if (kingSquare) kingSquare.classList.add('check');
                    }
                }
            }

            async handleSquareClick(row, col) {
                if (this.thinking || this.engine.isGameOver() || !this.isPlaying) return;

                if (this.gameMode === "player-vs-bot" && this.gameState.turn !== "white") return;

                const position = { row, col };
                const piece = this.engine.getPiece(position);

                if (this.selectedPiece) {
                    // Check if clicking on a valid move
                    const isValidMove = this.validMoves.some(move => move.row === row && move.col === col);
                    
                    if (isValidMove) {
                        await this.makePlayerMove(this.selectedPiece, position);
                        this.selectedPiece = null;
                        this.validMoves = [];
                    } else if (piece && piece.color === this.gameState.turn) {
                        // Select different piece
                        this.selectPiece(position);
                    } else {
                        // Deselect
                        this.selectedPiece = null;
                        this.validMoves = [];
                    }
                } else if (piece && piece.color === this.gameState.turn) {
                    this.selectPiece(position);
                }

                this.updateBoardHighlights();
            }

            selectPiece(position) {
                this.selectedPiece = position;
                try {
                    const moves = this.engine.generateMovesForPiece(position);
                    this.validMoves = moves.map(move => move.to);
                } catch (err) {
                    console.error("Error generating moves:", err);
                    this.validMoves = [];
                }
            }

            async makePlayerMove(from, to) {
                try {
                    const piece = this.engine.getPiece(from);
                    if (!piece) return false;

                    const move = {
                        from,
                        to,
                        piece,
                        capturedPiece: this.engine.getPiece(to),
                    };

                    const success = this.engine.makeMove(move);

                    if (success) {
                        const moveNotation = this.engine.moveToNotation(move);
                        this.moveHistory.push(moveNotation
